import os
import re
import random
from pathlib import Path
from itertools import product
from vunit import VUnit, VUnitCLI


def parse_port_names(filename):
    p = re.compile(r".*\s:\s[in|out].*")
    port_names = []
    with open(filename, "r") as f:
        for line in f.readlines():
            if p.match(line.strip()):
                port_names.append(line.split(":")[0].strip())
    return port_names


def parse_signal_names(filename):
    p = re.compile(r"\bsignal.*:.*:=.*;")
    signal_names = []
    with open(filename, "r") as f:
        for line in f.readlines():
            if p.match(line.strip()):
                signal_names.append(line.split(":")[0].split("signal")[1].strip())
    return signal_names


def generate_waveform_file(filename):
    lines = ["# THIS IS AUTOGENERATED CODE\n"]

    lines.append("set signals [list]\n")
    for signal in parse_signal_names("tb_spi_master.vhd"):
        lines.append(f'lappend signals "{signal}"\n')
    for port in parse_port_names(os.path.join("..", "spi_master.vhd")):
        lines.append(f'lappend signals "e_dut.{port}"\n')
    for signal in parse_signal_names(os.path.join("..", "spi_master.vhd")):
        lines.append(f'lappend signals "e_dut.{signal}"\n')

    lines.append("gtkwave::addSignalsFromList $signals\n")

    with open(filename, "w") as f:
        f.writelines(lines)


cli = VUnitCLI()
cli.parser.add_argument(
    "--warn",
    action="store_true",
    help="If this argument is present, errors of VUnit checkers are treated "
    "as warnings and the simulation continues if checks fail.",
)
args = cli.parse_args()

vu = VUnit.from_args(args=args)

vu.add_vhdl_builtins()
vu.add_osvvm()

spi_lib = vu.add_library("spi_lib")
spi_lib.add_source_files(Path(__file__).parent / "*.vhd")
spi_lib.add_source_files(Path(__file__).parent.parent / "*.vhd")

tb = spi_lib.test_bench("tb_spi_master")

test = tb.test("01_all_sclk_scs_idle_cases")
counter = 0
for sclk_idle_state in ["'0'", "'1'"]:
    for scs_idle_state in ["'0'", "'1'"]:
        counter += 1
        test.add_config(
            name=f"c{counter}.sclk_idle={sclk_idle_state}.scs_idle={scs_idle_state}",
            generics={
                "g_sclk_idle_state": sclk_idle_state,
                "g_scs_idle_state": scs_idle_state,
            },
        )

test = tb.test("02_all_sclk_transmit_edge_cases")
counter = 0
for sclk_idle_state in ["'0'", "'1'"]:
    for transmit_edge in ["'0'", "'1'"]:
        counter += 1
        test.add_config(
            name=f"c{counter}.sclk_idle={sclk_idle_state}.transmit_leading={transmit_edge}",
            generics={
                "g_sclk_idle_state": sclk_idle_state,
                "g_transmit_on_sclk_leading_edge": transmit_edge,
            },
        )

test = tb.test("03_sclk_divide")
counter = 0
for divide in [1, 2, 5, 10]:
    counter += 1
    test.add_config(
        name=f"c{counter}.max_sclk_divide={divide}",
        generics={
            "g_max_sclk_divide_half": divide,
        },
    )

test = tb.test("04_n_bits")
counter = 0
for n_bits in [1, 2, 3, 4]:
    counter += 1
    test.add_config(
        name=f"c{counter}.max_n_bits={n_bits}",
        generics={
            "g_max_n_bits": n_bits,
        },
    )

seed = random.randint(1_000_000, 9_999_999)

test = tb.test("05_transmit")
test.add_config(name=f"rng_seed={seed}", generics={"g_rng_seed": seed})

test = tb.test("06_receive")
test.add_config(name=f"rng_seed={seed}", generics={"g_rng_seed": seed})

test = tb.test("07_max_n_clks_scs_to_sclk")
counter = 0
for n_clks in [1, 2, 3, 4]:
    counter += 1
    test.add_config(
        name=f"c{counter}.max_n_clks_scs_to_sclk={n_clks}",
        generics={
            "g_max_n_clks_scs_to_sclk": n_clks,
        },
    )

test = tb.test("08_max_n_clks_sclk_to_scs")
counter = 0
for n_clks in [1, 2, 3, 4]:
    counter += 1
    test.add_config(
        name=f"c{counter}.max_n_clks_sclk_to_scs={n_clks}",
        generics={
            "g_max_n_clks_sclk_to_scs": n_clks,
        },
    )

test = tb.test("09_max_n_clks_rx_sample_strobes_delay")
counter = 0
for n_clks in [0, 1, 2, 3, 10]:
    counter += 1
    test.add_config(
        name=f"c{counter}.max_n_clks_rx_sample_strobes_delay={n_clks}",
        generics={
            "g_max_n_clks_rx_sample_strobes_delay": n_clks,
        },
    )

test = tb.test("11_deterministic_coverage")
timeout = "40 ms"
counter = 0
divide_halfs = [8]
bitss = [7]
scs_to_sclks = [6]
sclk_to_scss = [5]
sclk_to_les = [4]
le_widths = [3]
rx_delays = [2]
for (
    divide_half,
    bits,
    scs_to_sclk,
    sclk_to_scs,
    sclk_to_le,
    le_width,
    rx_delay,
) in product(
    divide_halfs, bitss, scs_to_sclks, sclk_to_scss, sclk_to_les, le_widths, rx_delays
):
    counter += 1
    test.add_config(
        name=f"c{counter}.seed={seed}.divide_half={divide_half}."
        f"bits={bits}.scs_to_sclk={scs_to_sclk}.sclk_to_scs={sclk_to_scs}."
        f"sclk_to_le={sclk_to_le}.le_width={le_width}.rx_delay={rx_delay}",
        generics={
            "g_rng_seed": seed,
            "g_watchdog_timeout": timeout,
            "g_max_sclk_divide_half": divide_half,
            "g_max_n_bits": bits,
            "g_max_n_clks_scs_to_sclk": scs_to_sclk,
            "g_max_n_clks_sclk_to_scs": sclk_to_scs,
            "g_max_n_clks_sclk_to_le": sclk_to_le,
            "g_max_n_clks_le_width": le_width,
            "g_max_n_clks_rx_sample_strobes_delay": rx_delay,
        },
    )

test = tb.test("13_random_coverage")
upper = 20
timeout = "10 ms"
counter = 0
divide_halfs = [random.randint(1, upper)]
bitss = [random.randint(1, upper)]
scs_to_sclks = [random.randint(1, upper)]
sclk_to_scss = [random.randint(1, upper)]
sclk_to_les = [random.randint(1, upper)]
le_widths = [random.randint(1, upper)]
rx_delays = [random.randint(0, upper)]
for (
    divide_half,
    bits,
    scs_to_sclk,
    sclk_to_scs,
    sclk_to_le,
    le_width,
    rx_delay,
) in product(
    divide_halfs, bitss, scs_to_sclks, sclk_to_scss, sclk_to_les, le_widths, rx_delays
):

    counter += 1
    test.add_config(
        name=f"c{counter}.seed={seed}.divide_half={divide_half}."
        f"bits={bits}.scs_to_sclk={scs_to_sclk}.sclk_to_scs={sclk_to_scs}."
        f"sclk_to_le={sclk_to_le}.le_width={le_width}.rx_delay={rx_delay}",
        generics={
            "g_rng_seed": seed,
            "g_watchdog_timeout": timeout,
            "g_max_sclk_divide_half": divide_half,
            "g_max_n_bits": bits,
            "g_max_n_clks_scs_to_sclk": scs_to_sclk,
            "g_max_n_clks_sclk_to_scs": sclk_to_scs,
            "g_max_n_clks_sclk_to_le": sclk_to_le,
            "g_max_n_clks_le_width": le_width,
            "g_max_n_clks_rx_sample_strobes_delay": rx_delay,
        },
    )

if args.warn:
    for test in tb.get_tests():
        test.set_generic("g_warning", True)

waveform_filename = "waveform.tcl"
generate_waveform_file(waveform_filename)

vu.set_sim_option(
    "ghdl.gtkwave_script.gui", str(Path(__file__).parent / waveform_filename)
)
vu.set_sim_option(
    "nvc.gtkwave_script.gui", str(Path(__file__).parent / waveform_filename)
)

vu.main()
